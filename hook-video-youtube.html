<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/utils/async.html">
<link rel="import" href="./hook-youtube-api.html">


<dom-module id="hook-video-youtube">
  <template>
    <style>
      :host {
        display: block;
        position: relative;
      }

      :host-context([count-click]) .youtube__iframe {
        position: relative;
        opacity: 0;
        cursor: pointer;
        z-index: 2;
        @apply --hook-video-iframe-clickable;
      }

      .youtube__iframe {
        @apply --hook-video-iframe;
      }
      
      :host-context([count-click]) .youtube__iframe--playing {
        opacity: 1;
        @apply --hook-video-iframe-playing;
      }

      :host-context([count-click]) .youtube__iframe--paused {
        opacity: 0;
        @apply --hook-video-iframe-paused;
      }

      :host-context([count-click]) .youtube__iframe--hover {
        @apply --hook-video-iframe-hovering;
      }

      .thumbnail {
        position: absolute;
        display: none;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        cursor: pointer;
        z-index: 1;
        background-color: #000;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center center;
        @apply --hook-video-thumbnail;
      }

      .thumbnail--hovering {
        @apply --hook-video-thumbnail-hovering;
      }

      .thumbnail--notclickable {
        pointer-events: none;
      }

      .thumbnail__icon {
        position: absolute;
        left: 50%;
        top: 50%;
        width: 68px;
        height: 48px;
        margin-left: -34px;
        margin-top: -24px;
        z-index: 1;
        -moz-transition: fill .1s cubic-bezier(0.0, 0.0, 0.2, 1), fill-opacity .1s cubic-bezier(0.0, 0.0, 0.2, 1);
        -webkit-transition: fill .1s cubic-bezier(0.0, 0.0, 0.2, 1), fill-opacity .1s cubic-bezier(0.0, 0.0, 0.2, 1);
        transition: fill .1s cubic-bezier(0.0, 0.0, 0.2, 1), fill-opacity .1s cubic-bezier(0.0, 0.0, 0.2, 1);
      }

      .youtube__iframe--unstarted {
        visibility: hidden;
      }

      .youtube__iframe--ended {
        visibility: hidden;
      }

      .youtube__iframe--buffering {
        visibility: visible;
      }

      .youtube__iframe--playing {
        visibility: visible;
      }

      .thumbnail__icon--hovering .ytp-large-play-button-bg {
        fill: #f00;
        fill-opacity: 1;
      }

      .thumbnail--paused {
        display: none;
      }
      
      .thumbnail--ended {
        display: block;
        @apply --hook-video-thumbnail-ended;
      }

      .thumbnail--playing {
        display: none;
        @apply --hook-video-thumbnail-ended;
      }

      .thumbnail--unstarted {
        display: block;
        @apply --hook-video-thumbnail-unstarted;
      }
      
    </style>
    <hook-youtube-api loaded="{{apiReady}}"></hook-youtube-api>
    <div class$="thumbnail [[computeClass(countClick, 'thumbnail--notclickable')]] [[computeClass(ended, 'thumbnail--ended')]] [[computeClass(unstarted, 'thumbnail--unstarted')]] [[computeClass(playing, 'thumbnail--playing')]] [[computeClass(hovering, 'thumbnail--hovering')]]" style$="[[computeThumbnailStyle(thumbnail)]]">
      <svg class$="thumbnail__icon [[computeClass(hovering, 'thumbnail__icon--hovering')]]" height="100%" version="1.1" viewBox="0 0 68 48" width="100%">
        <path class="ytp-large-play-button-bg" d="M66.52,7.74c-0.78-2.93-2.49-5.41-5.42-6.19C55.79,.13,34,0,34,0S12.21,.13,6.9,1.55 C3.97,2.33,2.27,4.81,1.48,7.74C0.06,13.05,0,24,0,24s0.06,10.95,1.48,16.26c0.78,2.93,2.49,5.41,5.42,6.19 C12.21,47.87,34,48,34,48s21.79-0.13,27.1-1.55c2.93-0.78,4.64-3.26,5.42-6.19C67.94,34.95,68,24,68,24S67.94,13.05,66.52,7.74z" fill="#212121" fill-opacity="0.8"></path>
        <path d="M 45,24 27,14 27,34" fill="#fff"></path>
      </svg>
    </div>
    <iframe id="player" class$="youtube__iframe [[computeClass(buffering, 'youtube__iframe--buffering')]] [[computeClass(ended, 'youtube__iframe--ended')]] [[computeClass(unstarted, 'youtube__iframe--unstarted')]] [[computeClass(playing, 'youtube__iframe--playing')]] [[computeClass(paused, 'youtube__iframe--paused')]]" type="text/html" width="100%" height="100%"
    src$="//www.youtube.com/embed/[[src]]?enablejsapi=1&autoplay=[[autoplay]]&origin=[[origin]][[computeChromelessPlayerVars(chromeless)]]" frameborder="0"></iframe>

  </template>

  <script>
    /**
     * `hook-video`
     * Polymer 2 video element for playing YouTube and HTML5 videos.
     *
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class HookVideoYouTube extends Polymer.Element {
      static get is() { return 'hook-video-youtube'; }
      static get properties() {
        return {
          debug: {
            type: Boolean,
            notify: true,
            value: false
          },
          apiReady: {
            type: Boolean,
            notify: true,
            observer: 'apiReadyChanged'
          },
          autoplay: {
            type: Boolean, 
            value: false,
            notify: true
          },
          countClick: {
            type: Boolean, 
            value: false,
            notify: true,
            observer: 'countClickChanged'
          },
          chromeless: {
            type: Boolean,
            value: false,
            notify: true
          },
          src: {
            type: String,
            notify: true,
            reflectToAttribute: true,
            observer: 'srcChanged'
          },
          origin: {
            type: String,
            value: () => { return window.location.protocol + '//' + window.location.host; }
          },
          state: {
            type: Number,
            notify: true
          },
          thumbnail: {
            type: String,
            notify: true,
            value: ''
          },
          unstarted: {
            type: Boolean,
            notify: true,
            readOnly: true,
            value: true,
            computed: 'computeUnstarted(state)'
          },
          buffering: {
            type: Boolean,
            notify: true,
            readOnly: true,
            value: false,
            computed: 'computePlaying(state)'
          },
          playing: {
            type: Boolean,
            notify: true,
            readOnly: true,
            value: false,
            computed: 'computePlaying(state)'
          },
          notplaying: {
            type: Boolean,
            notify: true,
            readOnly: true,
            value: true,
            computed: 'computeNotPlaying(state)'
          },
          paused: {
            type: Boolean,
            notify: true,
            readOnly: true,
            value: false,
            computed: 'computePaused(state)'
          },
          ended: {
            type: Boolean,
            notify: true,
            readOnly: true,
            value: false,
            computed: 'computeEnded(state)'
          },
          duration: {
            type: Number,
            notify: true,
            readOnly: true,
            computed: 'computeDuration(playing)'
          },
          hovering: {
            type: Boolean,
            notify: true,
            readOnly: true,
            value: false,
            reflectToAttribute: true,
          },
          currentTime: {
            type:Number,
            notify: true
          },
          /**
          * The fraction of the bytes that have been loaded for the current video, in the range [0-1].
          */
          fractionLoaded: {
            type: Number,
            value: 0,
            notify: true
          },

          /**
          * Returns the player's current volume, an integer between 0 and 100.
          * Note that `getVolume()` will return the volume even if the player is muted.
          */
          volume: {
            type: Number,
            value: 100,
            notify: true
          },


        };
      }

      constructor() {
        super();
        this.__playerClicked = this._playerClicked.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
      }

      /**
      * Clean up the underlying Player `<iframe>` when we're removed from the DOM.
      */
      disconnectedCallback() {
        if (this.player) {
          this.player.destroy();
        }
      }

      countClickChanged(val) {
        if(val) {
          this.removeEventListener('click', this.__playerClicked);
        }
        else {
          this.addEventListener('click', this.__playerClicked);
        }
      }

      _playerClicked(e) {
        if(this.debug) {
          console.log('hook-video-youtube._playerClicked()');
        }
        this.play();
      }

      _onPlayerReady() {
        if(this.debug) {
          console.log('hook-video-youtube._onPlayerReady()');
        }

        this.addEventListener('mouseenter', () => {
          if(this.debug) {
            console.log('hook-video-youtube.hovering');
          }
          this._setHovering(true);
        });
        this.addEventListener('mouseleave', () => {
          this._setHovering(false);
        });

        console.log(this);
      }

      _onPlayerStateChange(e) {
        if(this.debug) {
          console.log('hook-video-youtube._onPlayerStateChange()', e.data);
        }
        this.state = e.data;

        if (this.playing && !this.__updatePlaybackStatsInterval) {
          this.__updatePlaybackStatsInterval = setInterval(this._updatePlaybackStats.bind(this), 1000);
        }
        else {
          if(this.__updatePlaybackStatsInterval) {
            clearInterval(this.__updatePlaybackStatsInterval);
            this.__updatePlaybackStatsInterval = undefined;
          }
        }
      }

      apiReadyChanged() {
        if(this.debug) {
          console.log('hook-video-youtube.apiReadyChanged()');
        }
        if(this.apiReady) {
          this.player = new YT.Player(this.$.player, {
            events: {
              'onReady':this._onPlayerReady.bind(this),
              'onStateChange': this._onPlayerStateChange.bind(this)
            }
          });
        }
      }

      _updatePlaybackStats() {
        this.currentTime = Math.round(this.player.getCurrentTime());
        this.fractionLoaded = this.player.getVideoLoadedFraction();
        this.volume = this.player.getVolume();
      }

      computeUnstarted(state) {
        if(state === -1 || state === 5) {
          if(this.debug) {
            console.log('hook-video-youtube.UNSTARTED');
          }
          return true;
        }
        return false;
      }
      computeBuffering() {
        if(this.state === YT.PlayerState.BUFFERING) {
          if(this.debug) {
            console.log('hook-video-youtube.BUFFERING');
          }
          if(this._debounceJob) {
            this._debounceJob.cancel();
            this._debounceJob = null;
          }
          return true;
        }
        return false;
      }
      computePlaying() {
        if(this.state === YT.PlayerState.PLAYING) {
          if(this.debug) {
            console.log('hook-video-youtube.PLAYING');
          }
          return true;
        }
        return false;
      }
      computeNotPlaying() {
        if(this.state !== YT.PlayerState.PLAYING) {
          if(this.debug) {
            console.log('hook-video-youtube.NOT PLAYING');
          }
          return true;
        }
        if(this._debounceJob) {
          this._debounceJob.cancel();
          this._debounceJob = null;
        }
        return false;
      }
      computePaused() {
        if(this.state === YT.PlayerState.PAUSED) {
          if(this.debug) {
            console.log('hook-video-youtube.PAUSED');
          }
          this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob, Polymer.Async.timeOut.after(5000), () => { this._idleTimeout(); });
          return true;
        }
        return false;
      }

      computeEnded() {
        if(this.state === YT.PlayerState.ENDED) {
          if(this.debug) {
            console.log('hook-video-youtube.ENDED');
          }
          return true;
        }
        return false;
      }

      computeDuration(playing) {
        if(playing) {
          if(this.debug) {
            console.log('hook-video-youtube.DURATION', this.player.getDuration());
          }
          return this.player.getDuration();
        }
        return undefined;
      }

      computeChromelessPlayerVars(chromeless) {
        if(chromeless) {
          return '&controls=0&modestbranding=1&showinfo=0&iv_load_policy=3&rel=0';
        }
        return '';
      }

      computeClass(boolVal, classVal) {
        if(boolVal) {
          return classVal;
        }
        return '';
      }

      computeThumbnailStyle(thumbnail) {
        if(!thumbnail) {
          return "background-color: transparent; display: none;";
        }
        return "background-image: url(" + thumbnail + ");";
      }

      play() {
        if(this.debug) {
          console.log('hook-video-youtube.play()');
        }
        if(this.player) {
          this.player.playVideo();
        }
      }

      pause() {
        if(this.debug) {
          console.log('hook-video-youtube.pause()');
        }
        if(this.player) {
          this.player.pauseVideo();
          if(this._debounceJob) {
            this._debounceJob.cancel();
            this._debounceJob = null;
          }
        }
      }

      stop() {
        if(this.debug) {
          console.log('hook-video-youtube.stop()');
        }
        if(this.player && (this.playing || this.paused)) {
          this.player.stopVideo();
          if(this._debounceJob) {
            this._debounceJob.cancel();
            this._debounceJob = null;
          }
        }
      }

      mute() {
        if(this.debug) {
          console.log('hook-video-youtube.mute()');
        }
        if(this.player) {
          this.player.mute();
        }
      }

      unmute() {
        if(this.debug) {
          console.log('hook-video-youtube.unmute()');
        }
        if(this.player) {
          this.player.unmute();
        }
      }

      _idleTimeout() {
        this.stop();
      }

      /**
      * Skips ahead (or back) to the specified number of seconds.
      *
      * @method seekTo
      * @param {number} seconds Number of seconds to seek to.
      */
      seekTo(seconds) {
        if(this.debug) {
          console.log('hook-video-youtube.seekTo()', seconds);
        }
        if (this.player && this.player.seekTo) {
          this.player.seekTo(seconds, true);
          // Explicitly call _updatePlaybackStats() to ensure that the new playback info is
          // reflected in the bound attributes.
          // The 100ms delay is somewhat arbitrary, but the YouTube player does need time to
          // update its internal state following the call to player.seekTo().
          Polymer.Async.microTask.run(() => {
            this._updatePlaybackStats();
          });
        }
      }


    }

    window.customElements.define(HookVideoYouTube.is, HookVideoYouTube);
  </script>
</dom-module>